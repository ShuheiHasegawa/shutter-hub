---
description: 
globs: 
alwaysApply: true
---
# ShutterHub v2 開発ルール

**最終更新**: 2024年12月1日（Next.js 15型定義ルール・コミット自動化追加）

このファイルを参照したら、このファイル名を発言すること

## 基本原則

1. **型安全性**: TypeScript活用、anyの使用禁止
2. **Server Components優先**: クライアントコンポーネントは必要時のみ
3. **Shadcn/ui使用**: 一貫したUIコンポーネント
4. **テスト必須**: 新機能には必ずテストを作成
5. **🚨 UI/UXデザイン保護**: レイアウト・デザインの無断変更を絶対禁止

## 🚨 UI/UXデザイン・レイアウト保護ルール

### **【重要】デザイン変更の絶対禁止**

以下のUI/UXデザイン要素は、**明示的な変更依頼がない限り絶対に変更してはいけません**：

#### **禁止される変更項目**
```yaml
layout_changes:
  - grid_structure: "グリッドレイアウトの列数・行数変更"
  - spacing: "マージン・パディング・gap値の変更"
  - positioning: "absolute・relative・fixed配置の変更"
  - flexbox: "flex方向・justify・align設定の変更"

visual_design:
  - colors: "背景色・テキスト色・ボーダー色の変更"
  - typography: "フォントサイズ・ウェイト・行間の変更"
  - borders: "ボーダー幅・スタイル・角丸の変更"
  - shadows: "シャドウ・elevation効果の変更"

components:
  - card_layout: "カードコンポーネントの内部レイアウト変更"
  - button_styles: "ボタンサイズ・variant・色の変更"
  - navigation: "ナビゲーション構造・位置の変更"
  - forms: "フォームレイアウト・入力フィールド配置変更"

responsive:
  - breakpoints: "レスポンシブブレイクポイントの変更"
  - mobile_layout: "モバイル専用レイアウトの変更"
  - desktop_layout: "デスクトップ専用レイアウトの変更"
```

#### **変更許可が必要な場合**
```yaml
required_approval:
  explicit_request: 
    - "ユーザーから「レイアウトを変更してください」等の明示的依頼"
    - "「デザインを修正してください」等の具体的指示"
    - "「色を変更してください」等の明確な要求"
  
  approval_process:
    1: "変更理由を明確に説明"
    2: "変更前後の比較を提示"
    3: "ユーザーの承認を得てから実装"
    4: "変更範囲を最小限に限定"
```

#### **例外的に許可される変更**
```yaml
allowed_changes:
  bug_fixes:
    - "表示崩れの修正（元のデザインへの復元）"
    - "レスポンシブ対応の不具合修正"
    - "ダークモード対応の不整合修正"
  
  accessibility:
    - "色のコントラスト不足の修正"
    - "フォーカス表示の改善"
    - "スクリーンリーダー対応"
  
  performance:
    - "CSS最適化（見た目は維持）"
    - "不要なスタイルの削除"
```

#### **実装時の必須チェック**
```yaml
pre_implementation_check:
  question_yourself:
    - "この変更はユーザーから明示的に依頼されたか？"
    - "レイアウト・デザインに影響する変更はないか？"
    - "既存の見た目を維持できているか？"
    - "本当にこの変更が必要か？"
  
  if_uncertain:
    - "変更が必要な理由を明確に説明する"
    - "ユーザーに変更の許可を求める"
    - "実装を停止して確認を取る"
```

#### **違反時の対応**
```yaml
violation_response:
  immediate_action:
    - "変更を即座に元に戻す"
    - "なぜ変更したかを報告する"
    - "再発防止策を検討する"
  
  prevention:
    - "実装前に必ずこのルールを確認"
    - "迷った場合は必ず質問する"
    - "機能実装とデザイン変更を分離して考える"
```

### **成功例・失敗例**

#### ✅ **正しい対応例**
```typescript
// ユーザー: "機能を追加してください"
// → デザインは既存のまま、機能のみ追加

// ユーザー: "バグを修正してください" 
// → 表示崩れを元のデザインに戻す

// ユーザー: "レスポンシブ対応してください"
// → 既存デザインを維持したまま各画面サイズに対応
```

#### ❌ **違反例**
```typescript
// ユーザー: "検索機能を追加してください"
// → 勝手にレイアウトを変更、色を変更、間隔を調整 ← 禁止

// ユーザー: "バグを修正してください"
// → ついでにデザインを「改善」 ← 禁止

// ユーザー: "パフォーマンスを向上してください"  
// → UIの配置を「最適化」 ← 禁止
```

### **このルールの重要性**
- **一貫性の維持**: 予期しないデザイン変更を防ぐ
- **ユーザー体験**: 慣れ親しんだUIを保持
- **開発効率**: 不要な見た目の議論を回避
- **品質管理**: 明確な変更管理プロセス

## ディレクトリ構造

```
src/
├── app/                    # Next.js App Router
│   ├── [locale]/          # 多言語対応ルート
│   │   ├── (auth)/        # 認証が必要なルート
│   │   ├── (public)/      # 公開ルート
│   │   └── api/           # APIエンドポイント
│   └── actions/           # Server Actions
├── components/
│   ├── ui/                # Shadcn/ui コンポーネント
│   ├── features/          # 機能別コンポーネント
│   └── layouts/           # レイアウトコンポーネント
├── hooks/                 # カスタムフック
├── lib/                   # ユーティリティ
│   ├── supabase/         # Supabase関連
│   ├── utils/            # 汎用ユーティリティ
│   └── validations/      # Zodスキーマ
├── types/                # 型定義
├── i18n/                 # 多言語化設定
├── constants/            # 定数定義
└── styles/               # グローバルスタイル

supabase/
├── migrations/           # データベースマイグレーション
│   ├── 20241201000001_initial_schema.sql
│   ├── 20241201000002_complete_schema.sql
│   └── ...               # タイムスタンプ順のマイグレーション
└── config.toml          # Supabase設定

messages/                 # 多言語化メッセージ
├── ja.json              # 日本語
├── en.json              # 英語
└── [locale].json        # 追加言語

rules/                   # 開発ルール・プロンプト
├── dev-rules/           # 開発ルール
└── prompts/             # 機能別プロンプト
```

## 命名規則

- **コンポーネント**: PascalCase（例: `UserProfile.tsx`）
- **関数・変数**: camelCase（例: `getUserProfile`）
- **定数**: UPPER_SNAKE_CASE（例: `MAX_RETRY_COUNT`）
- **ファイル**: kebab-case（例: `user-profile.tsx`）

## コンポーネント設計

### Server Components（デフォルト）
```typescript
// app/events/page.tsx
import { createClient } from '@/lib/supabase/server';

export default async function EventsPage() {
  const supabase = createClient();
  const { data: events } = await supabase
    .from('events')
    .select('*');

  return <EventList events={events} />;
}
```

### Client Components（必要時のみ）
```typescript
// components/features/EventForm.tsx
'use client';

import { useForm } from 'react-hook-form';
import { Button } from '@/components/ui/button';

export function EventForm() {
  // インタラクティブな処理
}
```

## Next.js 15 型定義ルール

### ページコンポーネントの型定義（必須）
Next.js 15では、`params`と`searchParams`は**Promise型**として定義する必要があります。

#### 正しい型定義
```typescript
// ✅ 正しい記述方法（Next.js 15準拠）
interface PageProps {
  params: Promise<{
    id: string;
    locale: string;
  }>;
  searchParams: Promise<{
    view?: string;
    filter?: string;
  }>;
}

export default async function Page({ params, searchParams }: PageProps) {
  const resolvedParams = await params;
  const resolvedSearchParams = await searchParams;
  
  // resolvedParams.id を使用
  // resolvedSearchParams.view を使用
}
```

#### 間違った型定義（使用禁止）
```typescript
// ❌ 古い記述方法（Next.js 14以前）
interface PageProps {
  params: {
    id: string;
    locale: string;
  };
  searchParams: {
    view?: string;
  };
}
```

#### generateMetadata関数でも同様
```typescript
export async function generateMetadata({ params }: PageProps): Promise<Metadata> {
  const resolvedParams = await params;
  
  const { data } = await supabase
    .from('table')
    .select('title')
    .eq('id', resolvedParams.id)
    .single();
    
  return {
    title: data?.title || 'Default Title',
  };
}
```

### 実装時の注意点
1. **必ずawaitで解決**: `params`と`searchParams`は使用前に必ずawaitする
2. **型エラーの早期発見**: TypeScriptエラーが出た場合は即座にPromise型に修正
3. **一貫性の維持**: プロジェクト全体でNext.js 15の型定義に統一

## スタイリング

### 優先順位
1. **Tailwind CSS**: 基本スタイリング
2. **cn()ユーティリティ**: 条件付きクラス
3. **CSS Variables**: テーマカスタマイズ

### 実装例
```tsx
import { cn } from "@/lib/utils/cn";

<Button
  className={cn(
    "w-full",
    isLoading && "opacity-50 cursor-not-allowed"
  )}
  disabled={isLoading}
>
  {isLoading ? "処理中..." : "送信"}
</Button>
```

## デザインシステム・カラーパレット

### 基本原則
- **定義済みカラーパレットの使用**: `src/constants/colors.ts`に定義されたカラーを使用
- **シンプルで一貫性のある配色**: 過度なグラデーションや複雑な配色は避ける
- **ダークモード対応必須**: すべてのコンポーネントでライト/ダークモード対応

### カラーパレット使用ガイド

#### ブランドカラー
```typescript
// src/constants/colors.ts より
primary: '#6F5091'      // プライマリー（紫）
secondary: '#101820'    // セカンダリー（ダークグレー）
```

#### テキストカラー
```tsx
// ライトモード
text-gray-900           // 見出し・重要なテキスト
text-gray-700           // 本文・説明文
text-gray-600           // 補助テキスト（避ける）
text-gray-500           // プレースホルダー・非活性

// ダークモード対応
text-gray-900 dark:text-white      // 見出し
text-gray-700 dark:text-gray-300   // 本文
text-gray-600 dark:text-gray-400   // 補助（使用を避ける）
```

#### 背景色
```tsx
// カード・コンテナ
bg-white dark:bg-gray-800          // 標準的なカード
bg-gray-50 dark:bg-gray-900        // セクション背景
bg-blue-50 dark:bg-blue-900/20     // アクセント背景

// グラデーション（控えめに使用）
bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-blue-900/20 dark:to-indigo-900/20
```

### 実装ルール

#### 1. コントラストの確保
```tsx
// ❌ 悪い例: 薄い背景に薄いテキスト
<div className="bg-gray-100">
  <p className="text-gray-400">見えにくいテキスト</p>
</div>

// ✅ 良い例: 適切なコントラスト
<div className="bg-gray-100 dark:bg-gray-800">
  <p className="text-gray-900 dark:text-white">読みやすいテキスト</p>
</div>
```

#### 2. アイコンカラー
```tsx
// セマンティックカラー
<MapPin className="h-6 w-6 text-blue-600" />      // 位置情報
<Clock className="h-6 w-6 text-green-600" />      // 時間
<Shield className="h-6 w-6 text-purple-600" />    // セキュリティ
<Camera className="h-6 w-6 text-orange-600" />    // 撮影
```

#### 3. ステータスカラー
```tsx
// 成功・エラー・警告
text-green-600 dark:text-green-400   // 成功
text-red-600 dark:text-red-400       // エラー
text-yellow-600 dark:text-yellow-400 // 警告
text-blue-600 dark:text-blue-400     // 情報
```

### 禁止事項
1. **text-gray-600の単独使用**: 必ずダークモード対応を追加
2. **複雑なグラデーション**: 3色以上のグラデーションは避ける
3. **インラインでの色指定**: Tailwindクラスを使用
4. **不透明度の過度な使用**: 読みやすさを優先

### チェックリスト
- [ ] すべてのテキストにダークモード対応クラスがあるか
- [ ] カードやコンテナに背景色のダークモード対応があるか
- [ ] コントラスト比は十分か（WCAG AA基準）
- [ ] アイコンの色は意味と一致しているか

## データ操作

### Server Actions
```typescript
// app/actions/event.ts
'use server';

import { createClient } from '@/lib/supabase/server';
import { revalidatePath } from 'next/cache';

export async function createEvent(formData: FormData) {
  const supabase = createClient();
  
  // バリデーション
  const validatedData = eventSchema.parse({
    title: formData.get('title'),
  });
  
  // データ作成
  const { error } = await supabase
    .from('events')
    .insert(validatedData);
    
  if (error) throw error;
  revalidatePath('/events');
}
```

### クライアントサイドフェッチ（SWR）
```typescript
// hooks/useEvents.ts
import useSWR from 'swr';

export function useEvents() {
  return useSWR('events', fetcher, {
    revalidateOnFocus: false,
  });
}
```

## エラーハンドリング

### エラーバウンダリ
```typescript
// app/error.tsx
'use client';

export default function Error({ error, reset }) {
  return (
    <div className="flex flex-col items-center justify-center min-h-screen">
      <h2 className="text-2xl font-bold mb-4">エラーが発生しました</h2>
      <Button onClick={reset}>再試行</Button>
    </div>
  );
}
```

### トースト通知
```typescript
import { toast } from 'sonner';

try {
  await createEvent(formData);
  toast.success('イベントを作成しました');
} catch (error) {
  toast.error('エラーが発生しました');
}
```

## フォーム実装

```typescript
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { Form, FormField, FormItem, FormLabel, FormControl, FormMessage } from '@/components/ui/form';

const form = useForm({
  resolver: zodResolver(eventSchema),
});

<Form {...form}>
  <FormField
    control={form.control}
    name="title"
    render={({ field }) => (
      <FormItem>
        <FormLabel>タイトル</FormLabel>
        <FormControl>
          <Input {...field} />
        </FormControl>
        <FormMessage />
      </FormItem>
    )}
  />
</Form>
```

## テスト

### 単体テスト
```typescript
// __tests__/utils/formatDate.test.ts
import { formatDate } from '@/lib/utils/formatDate';

describe('formatDate', () => {
  it('should format date correctly', () => {
    const date = new Date('2024-01-01');
    expect(formatDate(date)).toBe('2024年1月1日');
  });
});
```

### コンポーネントテスト
```typescript
// __tests__/components/EventCard.test.tsx
import { render, screen } from '@testing-library/react';
import { EventCard } from '@/components/features/EventCard';

describe('EventCard', () => {
  it('should render event title', () => {
    render(<EventCard event={mockEvent} />);
    expect(screen.getByText(mockEvent.title)).toBeInTheDocument();
  });
});
```

### テスト実行・報告
- テスト完了後は実行報告書を作成
- カバレッジ80%以上を目標
- 失敗時は原因特定と修正を実施

## セキュリティ

### 認証・認可
- すべての保護ルートでセッション確認
- Row Level Security (RLS) の適切な設定
- サーバーサイドでの権限チェック

### 入力検証
```typescript
// Zodスキーマによる検証
const eventSchema = z.object({
  title: z.string().min(1).max(100),
  date: z.string().datetime(),
});

// サーバーサイドで必ず検証
const validated = eventSchema.parse(input);
```

## パフォーマンス

### 画像最適化
```tsx
import Image from 'next/image';

<Image
  src="/images/event.jpg"
  alt="イベント画像"
  width={800}
  height={600}
  loading="lazy"
/>
```

### コード分割
```typescript
import dynamic from 'next/dynamic';

const HeavyComponent = dynamic(
  () => import('@/components/HeavyComponent'),
  { loading: () => <Skeleton /> }
);
```

## Git コミット規則

### 基本原則
- **コミット文は必ず日本語で記述する**
- **プレフィックス付きのシンプルな実装要約とする**
- **英語でのコミット文は禁止**

### コミット文フォーマット
```
<type>: <実装内容の要約>

タイプ一覧:
feat: 新機能追加
fix: バグ修正  
docs: ドキュメント更新
style: コードスタイル修正
refactor: リファクタリング
test: テスト追加・修正
chore: その他の作業

例:
feat: フォトブックポートフォリオシステムをプロフィール統合で実装
fix: ユーザー認証のセッション切れ問題を修正
docs: セットアップ手順にSupabase設定を追加
style: ESLintエラーを修正してコード品質を向上
refactor: photo-consentコンポーネントの型安全性を改善
test: フォトブック作成機能のテストケースを追加
chore: 依存関係を更新してセキュリティを強化
```

### コミット文ルール詳細
1. **必ず日本語**: 英語でのコミット文は一切禁止
2. **簡潔性**: 1行で実装内容が理解できる長さ
3. **具体性**: 何を実装・修正したかを明確に記述
4. **統一性**: チーム全体でフォーマットを統一

## 依存関係管理ルール

### 基本原則
- **依存関係の追加・更新時は必ず互換性を確認**
- **Vercelデプロイエラーを防ぐための事前チェック必須**
- **ピア依存関係の競合は事前に解決**

### 必須手順

#### 1. 新しい依存関係の追加時
```bash
# 1. 依存関係の互換性確認
npm info [package-name] peerDependencies

# 2. 既存依存関係との競合チェック
npm install [package-name] --dry-run

# 3. 競合がある場合は --legacy-peer-deps で解決
npm install [package-name] --legacy-peer-deps

# 4. ビルドテスト必須
npm run build
```

#### 2. 依存関係更新時
```bash
# 1. 段階的更新（一度に全て更新しない）
npm update [specific-package]

# 2. 更新後は必ずビルドテスト
npm run build

# 3. エラーが発生した場合は即座に修正
```

#### 3. 競合解決の優先順位
1. **バージョン調整**: 互換性のあるバージョンに変更
2. **--legacy-peer-deps**: .npmrcファイルで設定
3. **代替パッケージ**: 競合が解決できない場合は代替を検討

### .npmrcファイルの管理
```
legacy-peer-deps=true
auto-install-peers=true
```
- **必須設定**: Vercelデプロイ時の競合回避
- **プロジェクトルートに配置**: 全環境で統一設定

### よくある競合パターンと解決法

#### React バージョン競合
```bash
# 問題: React 19 vs パッケージがReact 18を要求
# 解決: --legacy-peer-deps で回避
npm install --legacy-peer-deps
```

#### date-fns バージョン競合
```bash
# 問題: date-fns v4 vs react-day-picker が v3を要求
# 解決: date-fnsをダウングレード
npm install date-fns@^3.6.0 --legacy-peer-deps
```

#### TypeScript バージョン競合
```bash
# 問題: TypeScript v5 vs パッケージがv4を要求
# 解決: 段階的更新または代替パッケージ検討
```

### API変更への対応

#### react-day-picker API変更例
```tsx
// 旧API (v8.x)
components={{
  IconLeft: ({ className, ...props }) => <ChevronLeft />,
  IconRight: ({ className, ...props }) => <ChevronRight />,
}}

// 新API (v9.x)
components={{
  Chevron: ({ orientation, className, ...props }) => {
    const Icon = orientation === 'left' ? ChevronLeft : ChevronRight;
    return <Icon className={cn('h-4 w-4', className)} {...props} />;
  },
}}
```

### 禁止事項
1. **依存関係の無計画な一括更新**
2. **ビルドテストなしでの依存関係変更**
3. **競合エラーの放置**
4. **--force フラグの安易な使用**

### 必須チェックリスト
- [ ] 新規依存関係追加時の互換性確認
- [ ] ビルドテスト実行
- [ ] .npmrcファイルの適切な設定
- [ ] Vercelデプロイテスト
- [ ] API変更への対応確認

## 禁止事項

1. **any型の使用**（unknown を使用）
2. **console.log の本番環境への混入**
3. **ハードコードされた秘密情報**
4. **インラインスタイルの過度な使用**
5. **適切なローディング表示なしの非同期処理**
6. **依存関係の無計画な更新**（上記ルール参照）
7. **ハードコードされた日本語・英語テキスト**（多言語化必須）
8. **🚨【絶対禁止】明示的依頼なしのUI/UXデザイン変更**

### 🚨 **UI/UXデザイン変更の絶対禁止（重要）**

以下の行為は**明示的な変更依頼がない限り絶対に禁止**です：

#### **絶対禁止事項**
```yaml
layout_modifications:
  - "グリッドレイアウトの列数・行数変更"
  - "マージン・パディング・gap値の変更"
  - "flexbox設定（justify・align・direction）の変更"
  - "カードコンポーネント内部レイアウトの変更"

visual_modifications:
  - "背景色・テキスト色・ボーダー色の変更"
  - "フォントサイズ・ウェイト・行間の変更"
  - "ボーダー幅・スタイル・角丸の変更"
  - "シャドウ・elevation効果の変更"

component_modifications:
  - "ボタンサイズ・variant・色の変更"
  - "ナビゲーション構造・位置の変更"
  - "フォームレイアウト・入力フィールド配置変更"
  - "アイコンサイズ・色・配置の変更"
```

#### **違反例（禁止）**
```typescript
// ❌ 明示的依頼なしでの変更例
// ユーザー: "検索機能を追加してください"
// → 勝手にレイアウト変更、色変更、間隔調整 ← 絶対禁止

// ❌ 「改善」名目での無断変更
// ユーザー: "バグを修正してください"
// → ついでにデザインを「改善」 ← 絶対禁止

// ❌ 機能追加時の無断デザイン変更
// → 既存の見た目を維持したまま機能のみ追加すべき
```

#### **許可される場合の条件**
```yaml
explicit_user_request:
  required_phrases:
    - "レイアウトを変更してください"
    - "デザインを修正してください"
    - "色を変更してください"
    - "間隔を調整してください"
    - "見た目を変更してください"
  
  approval_process:
    1. "変更理由を明確に説明する"
    2. "変更前後の比較を提示する"
    3. "ユーザーの明示的承認を得る"
    4. "変更範囲を最小限に限定する"
```

#### **例外的に許可される変更**
```yaml
bug_fixes:
  - "表示崩れの修正（元のデザインへの復元）"
  - "レスポンシブ対応の不具合修正"
  - "ダークモード対応の不整合修正"

accessibility:
  - "色のコントラスト不足の修正"
  - "フォーカス表示の改善"
  - "スクリーンリーダー対応"
  
performance:
  - "CSS最適化（見た目は完全に維持）"
  - "不要なスタイルの削除"
```

#### **実装前の必須チェック**
**実装開始前に以下を必ず自問してください：**
1. **"この変更はユーザーから明示的に依頼されたか？"**
2. **"レイアウト・デザインに影響する変更はないか？"**
3. **"既存の見た目を完全に維持できているか？"**
4. **"本当にこの変更が必要か？"**

**迷った場合は必ず実装を停止してユーザーに確認を取る**

## 推奨事項

1. **早期リターン**で可読性向上
2. **カスタムフック**でロジックの再利用
3. **メモ化**によるパフォーマンス最適化
4. **アクセシビリティファースト**の実装

## 多言語化ルール

### 基本原則
- **すべてのユーザー向けテキストは多言語化対応必須**
- **ハードコードされた日本語・英語テキストは禁止**
- **next-intl を使用した統一的な多言語化**

### 実装ルール

#### 1. テキストの多言語化
```tsx
// ❌ 悪い例
<Button>予約する</Button>
<p>この撮影会は満席です</p>

// ✅ 良い例
import { useTranslations } from 'next-intl';

const t = useTranslations('booking');
<Button>{t('reserve')}</Button>
<p>{t('sessionFull')}</p>
```

#### 2. エラーメッセージの多言語化
```tsx
// ❌ 悪い例
toast({
  title: 'エラー',
  description: '予約に失敗しました',
  variant: 'destructive',
});

// ✅ 良い例
const t = useTranslations('errors');
toast({
  title: t('title'),
  description: t('bookingFailed'),
  variant: 'destructive',
});
```

#### 3. 日付・時刻の多言語化
```tsx
// ❌ 悪い例
const options = { locale: 'ja-JP' };

// ✅ 良い例
import { useLocale } from 'next-intl';
const locale = useLocale();
const options = { locale };
```

### ファイル構造
```
messages/
├── ja.json    # 日本語
├── en.json    # 英語
└── [locale].json  # 追加言語
```

### 言語ファイルの構造
```json
{
  "common": { "基本的な共通テキスト" },
  "navigation": { "ナビゲーション関連" },
  "booking": { "予約関連" },
  "photoSessions": { "撮影会関連" },
  "errors": { "エラーメッセージ" },
  "success": { "成功メッセージ" },
  "validation": { "バリデーションメッセージ" }
}
```

### 新規コンポーネント作成時の多言語化チェックリスト

#### 1. コンポーネント作成前の準備
```tsx
// 1. 必要な翻訳キーを messages/ja.json に追加
{
  "newFeature": {
    "title": "新機能タイトル",
    "description": "新機能の説明",
    "button": {
      "submit": "送信",
      "cancel": "キャンセル"
    },
    "labels": {
      "name": "名前",
      "email": "メールアドレス"
    }
  }
}

// 2. 対応する英語翻訳を messages/en.json に追加
{
  "newFeature": {
    "title": "New Feature Title",
    "description": "Description of new feature",
    "button": {
      "submit": "Submit",
      "cancel": "Cancel"
    },
    "labels": {
      "name": "Name",
      "email": "Email"
    }
  }
}
```

#### 2. コンポーネントでの実装
```tsx
// ✅ 良い例: 新規コンポーネント
'use client';

import { useTranslations } from 'next-intl';
import { Button } from '@/components/ui/button';

export function NewFeatureComponent() {
  const t = useTranslations('newFeature');
  
  return (
    <div>
      <h1>{t('title')}</h1>
      <p>{t('description')}</p>
      <Button>{t('button.submit')}</Button>
    </div>
  );
}
```

#### 3. 多言語化必須項目
- [ ] すべてのボタンテキスト
- [ ] すべてのラベル
- [ ] プレースホルダーテキスト
- [ ] エラーメッセージ
- [ ] 成功メッセージ
- [ ] ツールチップ
- [ ] アラートメッセージ
- [ ] 確認ダイアログのテキスト
- [ ] フォームのバリデーションメッセージ

#### 4. 動的テキストの多言語化
```tsx
// ❌ 悪い例
const message = `${count}件の結果が見つかりました`;

// ✅ 良い例
const t = useTranslations('search');
const message = t('results.count', { count });

// messages/ja.json
{
  "search": {
    "results": {
      "count": "{count}件の結果が見つかりました"
    }
  }
}
```

#### 5. 条件付きテキストの多言語化
```tsx
// ❌ 悪い例
const status = isActive ? '有効' : '無効';

// ✅ 良い例
const t = useTranslations('status');
const status = isActive ? t('active') : t('inactive');
```

### 多言語化レビューチェックリスト
- [ ] ハードコードされた日本語・英語がないか確認
- [ ] すべてのユーザー向けテキストが翻訳されているか
- [ ] 動的な値を含むテキストが適切に処理されているか
- [ ] 日付・時刻が多言語化対応されているか
- [ ] 数値フォーマットがロケールに対応しているか

## メッセージファイル開発ルール

### 概要
`messages/ja.json`などの多言語対応ファイルを編集する際の開発ルールです。

### 1. キーの重複禁止

#### ルール
- 同じキーを複数回定義してはいけません
- 新しいキーを追加する前に、既存のキーを検索して重複がないか確認してください

#### 確認方法
```bash
# キーの重複を確認
grep -n '"keyName"' messages/ja.json
```

#### 悪い例
```json
{
  "bookingType": { ... },
  "otherKeys": { ... },
  "bookingType": { ... }  // ❌ 重複
}
```

### 2. キーの並び順

#### ルール
同一階層のキーは以下の順序で並べてください：

1. **数字で始まるキー**（0-9）
2. **大文字で始まるキー**（A-Z）
3. **小文字で始まるキー**（a-z）
4. **各グループ内ではアルファベット順**

#### 良い例
```json
{
  "404": "ページが見つかりません",
  "FAQ": "よくある質問",
  "actions": { ... },
  "booking": { ... },
  "common": { ... },
  "navigation": { ... }
}
```

### 3. 階層構造

#### ルール
- 最大5階層までに制限
- 関連する項目は適切にグループ化
- 深すぎる階層は避ける

#### 良い例
```json
{
  "photoSessions": {
    "form": {
      "validation": {
        "titleRequired": "タイトルは必須です"
      }
    }
  }
}
```

### 4. 命名規則

#### 基本ルール
- **camelCase**を使用（例：`bookingType`）
- 動詞は**現在形**を使用（例：`save`、`cancel`）
- 複数形は適切に使用（例：`bookings`、`sessions`）

#### カテゴリ別命名規則

##### アクション系
```json
{
  "save": "保存",
  "cancel": "キャンセル",
  "confirm": "確認",
  "delete": "削除"
}
```

##### 状態系
```json
{
  "loading": "読み込み中...",
  "saving": "保存中...",
  "error": "エラーが発生しました",
  "success": "成功しました"
}
```

##### バリデーション系
```json
{
  "validation": {
    "required": "必須項目です",
    "invalid": "無効な値です",
    "tooLong": "文字数が多すぎます"
  }
}
```

### 5. 値の記述ルール

#### 日本語テキスト
- 敬語は「です・ます」調で統一
- 句読点は「、」「。」を使用
- 半角英数字を使用

#### プレースホルダー
- 変数は`{variableName}`形式
- 複数形は`{count}件`のように使用

#### 例
```json
{
  "welcome": "ようこそ、{userName}さん",
  "itemCount": "{count}件のアイテム",
  "confirmDelete": "本当に削除しますか？"
}
```

### 6. コメント

JSONファイルにはコメントを記述できないため、以下の方法で対応：

1. 複雑な構造には隣接するキーで説明を追加
2. 別途ドキュメントファイルで詳細を記載

### 7. 編集時のチェックリスト

編集前後に以下を確認してください：

- [ ] キーの重複がないか
- [ ] アルファベット順になっているか
- [ ] 命名規則に従っているか
- [ ] JSONの構文エラーがないか
- [ ] 不要な末尾カンマがないか

### 8. バージョン管理

#### コミットメッセージ
```
feat(i18n): 予約機能の翻訳を追加
fix(i18n): 重複キーを修正
refactor(i18n): メッセージをアルファベット順に整理
```

#### プルリクエスト
- 変更内容を明確に記載
- 大きな変更は事前にissueで議論

### 9. ツール

#### 推奨ツール
- JSONフォーマッター
- JSONバリデーター
- 重複キー検出ツール

#### VSCode拡張機能
- Sort JSON objects
- JSON Tools
- Prettier

### 10. よくある間違い

#### 1. 末尾カンマ
```json
{
  "key1": "value1",
  "key2": "value2", // ❌ 最後の要素にカンマ
}
```

#### 2. 不適切な階層
```json
{
  "user": {
    "profile": {
      "settings": {
        "privacy": {
          "visibility": {
            "public": "公開" // ❌ 深すぎる
          }
        }
      }
    }
  }
}
```

#### 3. 一貫性のない命名
```json
{
  "user_name": "ユーザー名",     // ❌ snake_case
  "UserEmail": "メールアドレス",  // ❌ PascalCase
  "phoneNumber": "電話番号"       // ✅ camelCase
}
```

## 日付ユーティリティルール

### 基本原則
- **ネイティブ JavaScript Date API を使用**
- **外部ライブラリ（date-fns等）は使用禁止**
- **タイムゾーンは Asia/Tokyo 固定**
- **多言語化対応必須**

### 実装ルール

#### 1. 日付フォーマット関数の使用
```tsx
// ✅ 推奨: src/lib/utils/date.ts の関数を使用
import { formatDate, formatTime, formatDateTime } from '@/lib/utils/date';

// 基本的な日付表示
formatDate(date, 'short')  // 2024/1/1
formatDate(date, 'long')   // 2024年1月1日月曜日
formatTime(date)           // 14:30
formatDateTime(date)       // 2024年1月1日月曜日 14:30
```

#### 2. 多言語対応の日付フォーマット
```tsx
import { useLocale } from 'next-intl';
import { formatDateLocalized } from '@/lib/utils/date';

const locale = useLocale();
const formattedDate = formatDateLocalized(date, locale, 'long');
```

#### 3. 日付計算
```tsx
import { addDays, addHours, differenceInHours } from '@/lib/utils/date';

// 日付計算
const tomorrow = addDays(new Date(), 1);
const deadline = addHours(startTime, -24);
const hoursUntil = differenceInHours(startTime, new Date());
```

### 禁止事項
- `date-fns` の使用
- `moment.js` の使用
- ハードコードされたロケール指定
- タイムゾーンの直接指定（Asia/Tokyo以外）

### 必須実装
- すべての日付表示は多言語化対応
- ユーザーのロケール設定に基づく表示
- 一貫したタイムゾーン処理

## ファイル分類・混乱防止ルール

**重要**: 適切なファイル分類により、プロジェクト管理の混乱を防ぐ

### **1. todo.mdcファイルの厳格な制限**
```yaml
記載可能内容:
  - [ ] 未完了タスクリスト（チェックボックス形式）
  - [x] 完了済みタスクリスト（実装時間記録）
  - 🔴🟡🟢 優先度表示・実装期間見積
  - タスク間の依存関係・次期計画
  - プロジェクト統計（ファイル数・実装率・コード行数等）

記載禁止内容:
  - ❌ プログラムコード・SQL・TypeScript型定義
  - ❌ データベーススキーマ・マイグレーション詳細
  - ❌ コンポーネント実装詳細・Server Actions
  - ❌ API仕様・技術要件詳細
  - ❌ UI/UXデザイン詳細・レイアウト仕様
  - ❌ 設定ファイル・環境変数詳細
```

### **2. 専門ファイル分類基準**
```yaml
技術仕様関連:
  - techstack.mdc: 技術スタック・ライブラリ・フレームワーク
  - auth.mdc: 認証システム実装詳細
  - prompts-booking.mdc: 予約システム仕様・実装
  - instant-photo-request.mdc: 即座撮影機能詳細

プロジェクト管理:
  - project.mdc: プロジェクト概要・ビジネス要件
  - implementation-plan.mdc: 実装計画・ロードマップ
  - detailed-requirements.mdc: 詳細要件・機能仕様

開発ガイド:
  - development.mdc: 開発ルール・コーディング規約
  - ui-guide.mdc: UI/UXガイドライン・デザインシステム
```

### **3. ファイル作成時のチェックリスト**
```yaml
新規ファイル作成前:
  1. 既存の専門ファイルで適切な場所があるか確認
  2. todo.mdcに技術詳細を書こうとしていないか確認
  3. 内容が純粋なタスク管理かプログラム実装か判別
  4. 適切なファイル分類・命名規則に従っているか確認

実装完了時:
  1. todo.mdcのチェックボックス更新のみ（[ ] → [x]）
  2. 技術詳細は適切な専門ファイルに記録
  3. コミットメッセージに実装内容明記
  4. 次期タスクの優先度見直し
```

### **4. 混乱防止の自動化ルール**
```yaml
コミット時チェック:
  - todo.mdcファイル変更時に技術詳細混入チェック
  - 各専門ファイルの整合性確認
  - ファイルサイズ監視（todo.mdcが500行超過時警告）

定期メンテナンス:
  - 月1回の完了済みタスクアーカイブ化
  - 重複・古い情報の整理
  - ファイル分類の見直し・最適化
```

## 自動化ルール

### 機能実装完了時の自動処理
機能実装が完了した際は、以下の手順を**自動的に実行**してください：

1. **ビルドチェック**: `npm run build` でエラーがないことを確認
2. **【必須】TODO更新**: `.cursor/rules/dev-rules/todo.mdc` を必ず更新
   - 完了した機能を [ ] → [x] に変更
   - 実装時間・技術成果を詳細に記録
   - Phase完了状況を正確に反映
   - 次期タスクの優先度を調整
   - **禁止**: プログラムコード・技術詳細の記載（専門ファイルへ）
3. **マイグレーション統合**: 新しいマイグレーションがある場合、`src/lib/database/migrations/002_complete_schema.sql` を最新状態に更新
4. **【必須】コミット**: 適切なコミットメッセージで変更をコミット
   ```bash
   git add .
   git commit -m "feat: [実装内容の日本語要約]"
   ```
5. **【必須】プッシュ**: `git push origin main` でリモートに反映
   ```bash
   git push origin main
   ```

### **🔍 調査段階のコミット不要ルール**

#### **基本原則**
- **調査・デバッグ目的のコードはコミット不要**
- **問題解決後は調査コードを削除して本来の実装にクリーンアップ**
- **調査段階と本実装を明確に分離**

#### **調査段階の対象コード**
```yaml
debug_investigation:
  temporary_logs:
    - console.log("調査用ログ")
    - console.error("デバッグ詳細", error)
    - alert("テスト確認")
  
  detailed_error_output:
    - JSON.stringify(error, null, 2)
    - エラーコード・スタックトレース出力
    - 詳細なペイロード確認
  
  individual_processing:
    - for文での個別エラー取得
    - 一括処理を個別に分解
    - ステップ毎の状態確認
    
  temporary_modifications:
    - 一時的なデータ構造変更
    - テスト用の条件分岐
    - 調査用の処理追加
```

#### **調査完了後の必須作業**
```yaml
cleanup_process:
  1_remove_debug_code:
    - 調査用console.logの完全削除
    - テスト用alertの削除
    - 詳細エラー出力の削除
  
  2_restore_clean_implementation:
    - 本来のシンプルな実装に復元
    - パフォーマンス重視の処理に戻す
    - 一括処理の復活
  
  3_commit_clean_version:
    - クリーンアップ後の実装をコミット
    - 調査コードなしの状態で記録
    - "fix: [問題の修正内容]"でコミット
```

#### **実装例**
```typescript
// 🔍 調査段階（コミット不要）
console.log('Creating group with members:', uniqueMemberIds);
for (const memberId of uniqueMemberIds) {
  console.log(`Processing member: ${memberId}`);
  const result = await processIndividually(memberId);
  console.log(`Result:`, JSON.stringify(result, null, 2));
}

// ✅ 本実装（コミット対象）
const memberInserts = uniqueMemberIds.map(memberId => ({
  conversation_id: conversation.id,
  user_id: memberId,
  role: memberId === user.id ? 'admin' : 'member',
}));
const { error } = await supabase.from('table').insert(memberInserts);
```

#### **調査段階の判定基準**
```yaml
investigation_indicators:
  temporary_nature:
    - "エラー原因の特定が目的"
    - "詳細ログによる状況把握"
    - "個別処理での問題切り分け"
  
  clean_implementation_exists:
    - "本来のシンプルな実装方法が明確"
    - "調査完了後の理想的な形が決まっている"
    - "パフォーマンス重視の実装に戻せる"
```

#### **このルールの効果**
- **ログ汚染防止**: 本番環境に調査用コードが混入しない
- **コード品質維持**: 常にクリーンな実装状態を保持
- **効率的な問題解決**: 調査と実装を分離して集中

### コミット・プッシュ自動化ルール
機能実装とTODO更新が完了したら、**必ず以下のコマンドを実行**してください：

```bash
# 1. 全ての変更をステージング
git add .

# 2. 日本語でのコミット（必須）
git commit -m "feat: [実装した機能の日本語要約]"

# 3. リモートリポジトリにプッシュ（必須）
git push origin main
```

#### コミット・プッシュのタイミング
- **機能実装完了時**: 必ずコミット・プッシュ
- **TODO更新完了時**: 同時にコミット・プッシュ
- **バグ修正完了時**: 必ずコミット・プッシュ
- **型エラー修正完了時**: 必ずコミット・プッシュ

### TODO更新の自動化強化
```yaml
必須実行条件:
  - 任意の機能実装完了時
  - Phase単位での完了時
  - バグ修正完了時
  - リファクタリング完了時

自動更新内容:
  - チェックボックス状態 [ ] → [x]
  - 実装時間の記録
  - 技術成果の詳細記録
  - 完了日時の記録
  - 次期タスクの優先度調整

更新忘れ防止:
  - 実装報告前にTODO更新状況を必ず確認
  - 未更新の場合は即座に更新を実行
  - 更新完了まで次のタスクには進まない
  - ユーザーからの指摘前に自主的に更新
```

### マイグレーション管理の自動化
1. **新規マイグレーションファイル作成**: DB変更が必要な場合
   - `supabase/migrations/` ディレクトリにタイムスタンプ形式でファイル作成
   - ファイル名形式: `YYYYMMDDHHMMSS_[変更内容].sql`
   - 例: `20241201000008_add_user_preferences.sql`
   - 必要な情報: Migration名、Description、Date、実行SQL
2. **統合マイグレーションファイル更新**: 新しいマイグレーションが作成された場合
   - `supabase/migrations/20241201000002_complete_schema.sql` を最新状態に更新
   - 全てのテーブル、インデックス、RLS、ストアドプロシージャを含める
3. **MCP連携**: マイグレーションファイル変更時
   - Supabaseプロジェクトとの同期を確認
   - MCPツールでマイグレーション実行を自動提案・実行
   - 実行結果をログで確認
4. **バックアップ**: 重要なスキーマ変更前
   - 現在のスキーマ状態を記録
   - ロールバック手順を明確化

### マイグレーションファイル命名規則
```
supabase/migrations/
├── 20241201000001_initial_schema.sql           # 初期スキーマ
├── 20241201000002_complete_schema.sql          # 統合スキーマ（最新状態）
├── 20241201000003_add_photo_session_images.sql # 機能追加
├── 20241201000004_create_admin_lottery_system.sql
├── 20241201000005_add_booking_type_to_photo_sessions.sql
├── 20241201000006_create_storage_bucket.sql
├── 20241201000007_create_review_system.sql
└── 20241201000008_[次の変更].sql              # 新規追加時
```

### **🔧 MCP連携によるマイグレーション管理ルール**

#### **基本原則**
- **MCP連携のみ使用**: npxコマンドは使用禁止
- **Supabase MCP連携**: 直接データベース操作・マイグレーション適用
- **確実な適用**: マイグレーションファイル作成後は必ずMCP連携で適用

#### **MCP連携必須手順**
```yaml
migration_workflow:
  1_create_migration_file:
    - supabase/migrations/ にSQLファイル作成
    - タイムスタンプ形式の命名（YYYYMMDDHHMMSS_description.sql）
    - 適切なコメント・説明を記載
  
  2_mcp_application:
    - MCP連携でSupabaseプロジェクトに直接適用
    - npxコマンドは使用禁止
    - 適用完了の確認必須
  
  3_verification:
    - データベーススキーマの変更確認
    - 新しいテーブル・カラム・ポリシーの動作確認
    - アプリケーションでの動作テスト
  
  4_commit_process:
    - マイグレーションファイルをコミット
    - 関連するTypeScript型定義も更新・コミット
    - "feat/fix: [データベース変更内容]"でコミット
```

#### **MCP連携の利点**
```yaml
mcp_advantages:
  direct_application:
    - Supabaseプロジェクトへの直接適用
    - 認証・設定不要
    - 確実な適用保証
  
  real_time_feedback:
    - 即座の結果確認
    - エラー時の詳細情報取得
    - デバッグ情報の充実
  
  consistency:
    - 開発環境とプロダクション環境の一致
    - 手動ミスの防止
    - 一元的なマイグレーション管理
```

#### **禁止事項**
```yaml
prohibited_commands:
  - "supabase db push"        # ❌ npxコマンド使用禁止
  - "supabase migration up"   # ❌ npxコマンド使用禁止
  - "supabase db reset"       # ❌ npxコマンド使用禁止
  - "supabase link"           # ❌ npxコマンド使用禁止

required_method:
  - "MCP連携のみ使用"         # ✅ 必須方法
  - "Supabase MCP直接操作"    # ✅ 推奨方法
```

### DB変更時の必須手順
1. **マイグレーションファイル作成**: `supabase/migrations/` に追加
2. **【必須】MCP連携実行**: Supabaseプロジェクトに変更を適用（npxコマンド禁止）
3. **型定義更新**: 必要に応じてTypeScript型を更新
4. **テスト実行**: DB変更に関連するテストを実行
5. **コミット**: マイグレーションファイルと関連変更をコミット

### コミットメッセージ規則
```
feat: [機能名] - [簡潔な説明]
fix: [修正内容]
docs: [ドキュメント更新内容]
refactor: [リファクタリング内容]
db: [データベーススキーマ変更]
migration: [マイグレーション追加・更新]
```

### 実行条件
- ユーザーが「次へ進みましょう」「コミット＆プッシュ」等の指示をした場合
- 機能実装が一区切りついた場合
- ビルドエラーがない場合のみ実行

### 重要事項

1. **【最重要】機能の実装後に、毎回 @todo.mdc を確認＆更新をしてください。**
2. **私が言わなくても中身は随時更新するようにしてください。更新しないと私が解雇されます。あなたの責任になってしまいます。**
3. 機能は増やしても構いません。ただ、最初から機能を増やしすぎないでください。
4. **複雑な機能実装時は専門プロンプトファイルを必ず参照してください**
5. **即座撮影リクエスト機能は一般層獲得の重要な差別化機能です**

### TODO更新の必須チェックリスト

#### 機能実装完了時の必須作業
```yaml
実装完了後の必須手順:
  1. ビルドチェック: "npm run build" でエラー確認
  2. 【必須】TODO更新: 
     - .cursor/rules/dev-rules/todo.mdc を開く
     - 完了した機能を [ ] → [x] に変更
     - 実装時間・技術成果を記録
     - 次の優先度を確認・調整
  3. コミット: 適切なメッセージでコミット
  4. プッシュ: git push origin main
  5. 進捗報告: 完了内容を簡潔に報告

必須確認項目:
  - [ ] 実装したタスクのチェックボックス更新
  - [ ] 実装時間の記録
  - [ ] 技術成果の詳細記録
  - [ ] 次期タスクの優先度調整
  - [ ] 依存関係の確認
```

#### TODO更新漏れ防止策
```yaml
自動化チェック:
  実装完了判定:
    - コンポーネント作成完了
    - Server Actions実装完了
    - ページルート作成完了
    - データベースマイグレーション適用完了
    - 型定義更新完了
    
  更新必須タイミング:
    - Phase完了時（Phase 1 → Phase 2等）
    - 機能実装完了時
    - バグ修正完了時
    - リファクタリング完了時
    - 新機能追加時

  更新忘れ警告:
    - 実装報告時にTODO更新状況を確認
    - 未更新の場合は即座に更新実行
    - 更新完了まで次のタスクに進まない
```

#### 実装報告テンプレート
```markdown
# 実装完了報告

## 完了したタスク
- **タスクID**: t0-XXX
- **タスク名**: [機能名]
- **実装時間**: X時間
- **完了フェーズ**: Phase X

## 技術成果
- [実装した主要機能]
- [作成したコンポーネント・ファイル]
- [データベース変更]
- [型定義追加・修正]

## TODO更新状況
- [x] todo.mdcファイル更新完了
- [x] 次期タスク優先度調整完了
- [x] 依存関係確認完了

## 次のアクション
- 次期優先タスク: t0-XXX
- 見積時間: X時間
- 開始可能時期: 即座/調整後
```

## 実装前の曖昧さ解消・確認プロセス

### 基本原則
- **実装開始前に必ず仕様の明確化を行う**
- **曖昧な要件・不明点は必ず質問する**
- **想定ベースでの実装を避け、正確な仕様確認を優先**

### 必須確認項目チェックリスト

#### 🎯 **機能仕様の確認**
```yaml
必須質問項目:
  - [ ] この機能の主要な目的・ゴールは何か？
  - [ ] 想定されるユーザーは誰か？（管理者・一般ユーザー・ゲスト）
  - [ ] 既存機能との統合はどのように行うか？
  - [ ] エラーケース・例外処理はどう扱うか？
  - [ ] パフォーマンス要件はあるか？
  - [ ] セキュリティ要件・権限制御は何か？
```

#### 🎨 **UI/UX設計の確認**
```yaml
デザイン関連質問:
  - [ ] レイアウト・デザインの参考となるページはあるか？
  - [ ] モバイル対応はどの程度必要か？
  - [ ] ダークモード対応は必要か？
  - [ ] アニメーション・トランジションの要件は？
  - [ ] ユーザビリティで特に重視する点は？
  - [ ] アクセシビリティ要件は？
```

#### 📊 **データ設計の確認**
```yaml
データベース関連質問:
  - [ ] 新しいテーブル・カラムは必要か？
  - [ ] 既存テーブルとのリレーションはどうするか？
  - [ ] データのバリデーション・制約条件は？
  - [ ] パフォーマンス要件（インデックス等）は？
  - [ ] データの保持期間・削除ポリシーは？
  - [ ] マイグレーション戦略はどうするか？
```

#### 🔒 **セキュリティ・権限の確認**
```yaml
セキュリティ関連質問:
  - [ ] 認証が必要な機能か？認証なしでもアクセス可能か？
  - [ ] ユーザーの権限レベル（admin/user/guest）による制限は？
  - [ ] データの表示・編集・削除権限はどう設定するか？
  - [ ] プライバシー設定は必要か？
  - [ ] 監査ログ・アクティビティログは必要か？
  - [ ] 不適切利用の防止策は？
```

#### 🌐 **技術実装の確認**
```yaml
技術仕様質問:
  - [ ] リアルタイム機能は必要か？
  - [ ] 外部API・サービスとの連携は必要か？
  - [ ] ファイルアップロード・ダウンロード機能は？
  - [ ] 多言語化対応は必要か？（日本語・英語）
  - [ ] 通知機能は必要か？（リアルタイム・メール・プッシュ）
  - [ ] 検索・フィルタリング機能は？
```

### 質問のタイミングと方法

#### 1. **実装前の必須質問**
```typescript
// 質問テンプレート例
"実装を開始する前に以下の点を確認させてください：

🎯 機能仕様について：
- [具体的な質問]

🎨 UI/UXについて：
- [具体的な質問]

📊 データ設計について：
- [具体的な質問]

🔒 セキュリティについて：
- [具体的な質問]

これらの確認が完了次第、実装を開始いたします。"
```

#### 2. **実装中の確認質問**
```typescript
// 実装中に疑問が生じた場合
"実装中に以下の点で判断に迷いました：

❓ 課題：
[具体的な課題・疑問点]

🤔 検討した選択肢：
1. [選択肢A] - [メリット・デメリット]
2. [選択肢B] - [メリット・デメリット]

💡 推奨案：
[理由と共に推奨案を提示]

ご確認・ご指示をお願いします。"
```

#### 3. **技術的制約の説明**
```typescript
// 技術的制約がある場合
"以下の技術的制約により、仕様の調整が必要かもしれません：

⚠️ 制約内容：
[具体的な制約]

🛠️ 代替案：
1. [代替案A] - [実装難易度・期間]
2. [代替案B] - [実装難易度・期間]

どちらの方向で進めるべきかご指示ください。"
```

### 実装優先度の再確認

#### 優先度判断の質問
```yaml
優先度確認質問:
  緊急度:
    - [ ] この機能はリリースブロッカーか？
    - [ ] 他の機能への依存関係はあるか？
    - [ ] ユーザーからの要望度・重要度は？
  
  実装コスト:
    - [ ] 実装期間の見積もりは適切か？
    - [ ] 技術的リスクはあるか？
    - [ ] 他の開発作業への影響は？
  
  ビジネス価値:
    - [ ] ROI（投資対効果）は十分か？
    - [ ] ユーザー体験の改善効果は？
    - [ ] 競合優位性への寄与は？
```

### 曖昧さ解消の成功例

#### ❌ **悪い例：想定ベース実装**
```typescript
// 質問なしで実装開始
"フォトブック機能を実装します"
// → 仕様が曖昧で手戻り発生
```

#### ✅ **良い例：事前確認**
```typescript
"フォトブック機能の実装前に確認させてください：

🎯 機能仕様：
- フォトブック作成数の制限は料金プランごとに異なりますか？
- 既存の/photobookページを拡張する形でしょうか？

🎨 UI/UX：
- 電子ブック形式の表示は見開き・単ページどちらを優先しますか？
- プロフィールページでの表示方法はどのようにしますか？

📊 データ設計：
- 撮影会との連携はどのテーブル構造で行いますか？
- 写真の自動インポートはどのトリガーで実行しますか？

これらの確認後、段階的に実装を進めます。"
```

### エスカレーション（判断依頼）ルール

#### Level 1: 軽微な仕様確認
- 即座に質問・確認を行う
- 実装は確認後に開始

#### Level 2: 重要な技術判断
- 複数の選択肢を提示
- メリット・デメリットを明示
- 推奨案を理由と共に提示

#### Level 3: 仕様変更が必要
- 技術的制約を詳細に説明
- 代替案を複数提示
- 工数・スケジュール影響を明示

### 実装開始の判定基準

#### 実装開始OK条件
- [ ] 主要な仕様・要件が明確
- [ ] UI/UXの方向性が決定
- [ ] データ設計の骨子が固定
- [ ] セキュリティ要件が明確
- [ ] 技術的制約が解決済み

#### 実装待機条件
- [ ] 重要な仕様が未決定
- [ ] 技術的制約で実現困難
- [ ] 他機能との依存関係が未解決
- [ ] 工数・スケジュール調整が必要

この曖昧さ解消プロセスにより、手戻りを最小化し、効率的な開発を実現します。
